Generics let you **write code once** and use it with **any data type**.

`<T>` means that this class or method needs a type when you use it ... note that you can pass multiple type values.

```CS
class Box<T> {
    public T Value;
}

Box<int> b1 = new Box<int>(); // T = int
Box<string> b2 = new Box<string>(); // T = string
```

Not only classes — methods can be generic too: 

```CS
public T Max<T>(T a, T b) where T : IComparable<T>{
    return a.CompareTo(b) > 0 ? a : b;
}

int m1 = Max(3, 5);         // T = int
string m2 = Max("a", "b");  // T = string

// Note that we didn't pass the type to the method .. the compiler
// can detect it automatically, but of course you can pass it.
```

`IComparable<T>`  .. It’s a built-in C# interface that allows objects to be compared with each other. 

**Generic constraints:** `where T : ...`

```CS
where T : class // Require a Class (Only Reference Types)
where T : struct // Require a struct (Only Value Types)
where T : IDisposable // Must implement an interface
where T : class, new() // Multiple Constraints
```

