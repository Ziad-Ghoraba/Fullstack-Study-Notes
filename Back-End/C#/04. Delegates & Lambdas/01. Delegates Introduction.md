**A delegate is a type-safe reference to a function** .. think of it as a **variable that can store a function**.

We need to use delegates because sometimes you want to **pass a function as a parameter** to another function, or **store a function**, or **choose which function to run at runtime**.

**Delegate is a reference type** .. so you **need to instantiate** it to be able to use it.

Remember that in the context of methods overloading method signature was defined as **method name + parameters** ... but here in delegates we will be defining method signature as **return type + parameters**.

```CS
// Define a delegate
public delegate int MathOperation(int x, int y);

// 1. Create functions that match the delegate signature
public static int Add(int x, int y) => x + y;
public static int Multiply(int x, int y) => x * y;

// 2. Create a delegate variable and store a function inside it
// Add is the target function
MathOperation op = new MathOperation(Add);  

int result = op.Invoke(5, 7); // Using Invoke()
Console.WriteLine(result); // 12

// Or invoke it directly (shorter)
Console.WriteLine(op(3, 4)); // 7

// 3. Change the function at runtime
op = Multiply;
Console.WriteLine(op(3, 4)); // 12
```
***
**Delegates as Parameters** .. This is the main power.

Example: a function that receives another function

```CS
static int Calculate(int x, int y, MathOperation operation){
    return operation(x, y); // call the delegate
}

Console.WriteLine(Calculate(5, 3, Add));      // 8
Console.WriteLine(Calculate(5, 3, Multiply)); // 15
```
***
The delegate has two properties which is **method & target** ... the method simply represent the method that the delegate is pointing at ... and the target represent the instance of the class that the method belongs to.

So if it's a static method the target will be just empty string .. but if it belongs to some class you will see the full address of the class.