
- You can think of the **namespace** as a container for some group of classes.
- In C# there's a **var** datatype which can be used for any type.
***
- In C# the data types are **Value type**, **Reference Type**, **Pointer Type**.

**Value Type**

- In the value type the **variable stores the entire value directly**.
- Assignment copies the value (deep copy of the memory of that value).

```CS
struct Point { public int x, y; }
Point a = new Point { x = 1, y = 2 };
Point b = a;
b.x = 99;
Console.WriteLine(a.x); // prints 1 — a and b are independent
```


**Reference Type**

- The **variable stores a reference** to an object stored elsewhere ... the actual object usually lives in the **heap**.
- Assignment copies the reference (both point to same object).

```CS
class Person { public string name; }

Person a = new Person { name = "Hamza" };
Person b = a;
b.name = "Ali";
Console.WriteLine(a.name); // prints "Ali" — both refer to same object

```
***
**Boxing** (Value type -> Ref type) .. (Implicit conversion).

```CS
int num = 15;
object ref = num;
```

**Unboxing** (Ref type -> Value type) .. (Explicit conversion).

```CS
object ref = 42;
int b = (int)ref;
```

- In C# the implicit conversion is always from small datatype to a bigger data type ... unlike the explicit.
- You can use `Convert.` to find a lot of converting methods.
***
```CS
int[] arr = new int[3]; // Note that the array is ref type.

int[] arr1 = new int[3] {5, 10, 15};
int[] arr2 = new int {5, 10, 15};
int[] arr3 = {5, 10, 15};

// arr.Min(), arr.Max(), arr.SUM() ..etc.
// also note the Array obj.
```

If will sperate the declaration and the assignment then in the assignment you will use `new int[]`.

```CS
foreach(var name in names_arr){
	// Block of Code
}
```

```CS
// Multidimensional vs Jaged Array

int [,] multi_dim_arr = new int[2,2] {{3,5}, {4, 6}};
int num = multi_dim_arr[1, 0];

int [][] = new int[3][] {
	// Add everyone
}
```
***
**String** is a reference type not value type.

```CS
string res = @"Hamza\nMahrous" // Instead of escape char
string res = $"result = {res_sum}"; // String interpolation
```
***
**Constants** -> don't require runtime memory allocation (hard coded to executable) ... **Variables** -> memory allocation (stack or heap).

use **const** keyword with constants.

To make some value nullable use `int? x = null` ... also note the coalescing operator. 

Note `try .. catch(Exception ex) .. finally` .. you could also cascade more than one catch and use the specific exception not the base class.

You could also return new exception by using `throw new Exception()`.
***
C# supports naming parameters.

To pass variable by reference you should use `ref int a` in the function arguments.

In C# there's output parameters ... note that you can out more than one variable.

- The method **must assign** a value to it before returning.
- The caller **must declare** it with `out`.

```CS
public static void addNumbers(int x, int y, out int sum){
	sum = x + y;
}

int result;
AddNumbers(10, 20, out result);

Console.WriteLine(result); // Output: 30
```

To pass a **variable number of arguments** in C# use `params int[] array` ... you can skip the **params** keyword but then you will pass an array object not arguments.

**Overloading** means that we can make two functions with the same name but the difference is that for example one takes integer and the other takes double and when calling it ... the compiler will decide based on the parameters ... note that the signature (function name, arguments list) mush be different ... also note that the functions logic could be different.

You can use **Locals** debugging window to see the variables value and also you can use **Autos** to see the values at this line ... you can also use the order **Add Watch** to some variable to be always seeing it's value.
