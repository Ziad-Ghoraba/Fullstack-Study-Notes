## Mock Functions

To understand the use case of mock functions, let's examine this scenario where we a have function for example called `add` that we are trying to test, but this function depends on another function called `log` that's logging some data to the console.

When we have a test suite that calls the `add` function many times, we will end up in a missy console due to so many logs, and here comes into play the mock functions as we can mock the `log` function to an empty function inside the test file and by this we won't see any logs to the console.

```JS
import {vi} from 'vitest'

vi.mock('src/helpers/loggers')
```

By adding this line we mocked the **whole module** by an **empty functions**, and if course we can mock them with a real implementation, but note that if we just returned an object with only one function mocked the other functions inside the module will be mocked as empty functions, so you might consider mixing the mocked implementation with the original module like the following code.

```JS
import { describe, it, expect, vi } from "vitest"

vi.mock('../src/helpers/loggers', async () => {
  const original = await vi.importActual('../src/helpers/loggers')
  
  return {
    ...originals,
    logDealRound: vi.fn(() => {
      console.log('logDealRound mock fn called')
    }),
  }
})
```

Also note that now we can track how many times this function have been called inside any test case and can also reset this counter for a specific test case, but if we didn't mock the function we wouldn't have been able to do this.

## Creating Spies

Creating a spy is different from mocking a function as here the original function will exist as it's unless you choose to change it's behavior, and also you can check how many times it has been called, check it's parameters and check it's return value. 

```JS
import { describe, it, expect, vi } from "vitest"

// import the modules to spy on
import * as shuffleModule from '../src/shuffle'
import * as dealModule from '../src/deal'

describe('setupGame', () => {
  const suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']
  const values = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King']

  it('calls shuffle before dealing cards', () => {
    const cards = createCards({ suits, values })
    
	// spyOn takes two parameters, the first is the module and    
	// the second is the name of the function to spy on it.
    const shuffleSpy = vi.spyOn(shuffleModule, 'shuffle')
    const dealSpy = vi.spyOn(dealModule, 'deal')

    setupGame(cards, 5, 3)

    expect(shuffleSpy).toHaveBeenCalledTimes(1)
    // mock isn't concerned with mocking functions, it's the
    // metadata that you will find your information
    expect(shuffleSpy.mock.invocationCallOrder[0])
      .toBeLessThan(dealSpy.mock.invocationCallOrder[0])
  })

  it('calls deal with correct arguments', () => {
    const cards = createCards({ suits, values })
    
    const dealSpy = vi.spyOn(dealModule, 'deal')
    const shuffleSpy = vi.spyOn(shuffleModule, 'shuffle')
  
    setupGame(cards, 5, 3)
    
    // Get the shuffled cards that shuffle returned
    const shuffledCards = shuffleSpy.mock.results[0].value
    expect(dealSpy).toHaveBeenCalledWith(shuffledCards, 5, 3)
  })
})
```