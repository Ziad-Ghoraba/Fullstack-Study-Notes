Testing async functions is very crucial to our frontend apps, as an example we will see in this file how to test a function that returns a promise as a simulation for async functions.

```JS
const DECKS = {
  standard: {
    suits: ["Hearts", "Diamonds", "Clubs", "Spades"],
    values: [
      "Ace","2","3","4","5","6","7","8","9","10","Jack","Queen",
	  "King"],
   },

  pokemon: {
    suits: ["Grass", "Fire", "Water", "Electric"],
    values: [
      "Ace","2","3","4","5","6","7","8","9","10","Pichu",
      "Pikachu","Raichu"],
   },
};

export function loadDeck(id = "standard") {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const deck = DECKS[id];
      if (!deck) {
        reject(new Error("Deck not found with that id"));
      }

      const suits = [...deck.suits];
      const values = [...deck.values];

      if (suits.length !== 4 || values.length !== 13) {
        reject(new Error("Expected 4 suits and 13 values"));
      }

      resolve({ suits, values });
    }, 0);
  });
}
```

```JS
import { describe, expect } from "vitest";
import { loadDeck } from "../examples/loadDeck";

describe("Load Deck", () => {
  it("returns a Promise that resolves", async () => {
    const result = loadDeck();
    
    expect(result).toBeInstanceOf(Promise);
    await expect(result).resolves.toBeDefined();
  });

  
  // check it resolves to the correct structure
  it("resolves a { suits[4], values[13] } deck", async () => {
    const result = await loadDeck()
    
    expect(result).toBeTypeOf("object");
    
    expect(result).toHaveProperty("suits");
    expect(result).toHaveProperty("values");

    expect(Array.isArray(result.suits)).toBe(true);
    expect(Array.isArray(result.values)).toBe(true);

    expect(result.suits).toHaveLength(4);
    expect(result.values).toHaveLength(13);
  });

  // check it supports other id's
  it('supports another id, e.g. "pokemon"', async () => {
    const result = await loadDeck("pokemon");
  
    expect(result.suits).toHaveLength(4);
    expect(result.values).toHaveLength(13);
  });

  // check it rejects unknown id's
  it("rejects with an error for unknown ids", async () => {
    const deck = loadDeck("unknown-id");

    await expect(deck).rejects.toThrow(/not found/i);
  });
});
```
***
Note that we have many matchers in the "resolves a { suits[4], values[13] } deck" test and they can be reduced using the asymmetric matchers.

Asymmetric matchers come into play when we want to match complex data type, like in our case where we have an object with two properties of the array type.

One of the differences between the regular matchers and the asymmetric matchers is that asymmetric ones don't start with **to**.

Now this how we can migrate the test to use asymmetric matchers.

```JS
it("resolves a { suits[4], values[13] } deck", async () => {
const result = await loadDeck();

expect(result).toEqual(
  expect.objectContaining({
	suits: expect.any(Array),
	values: expect.any(Array),
  })
);

expect(result.suits).toHaveLength(4);
expect(result.values).toHaveLength(13);
});
```

