## Introduction to OOP

- **OOP** stands for Object-Oriented Programming, a programming paradigm based on **objects** that contain:
    - **Data**: Fields (attributes or properties).
    - **Code**: Procedures (methods).

- **Class** vs **Object**:
    - A **class** is a blueprint or template defining properties and methods common to all objects of that type.
    - An **object** is an instance of a class, representing a specific entity created from the class blueprint.

## Key Principles of OOP

1. **Encapsulation**: Bundling data and methods that operate on that data, restricting direct access to some components.

2. **Inheritance**: Mechanism for a class to inherit properties and methods from another class.

3. **Polymorphism**: Ability for objects of different classes to be treated as objects of a common superclass, with methods behaving differently based on the object.

4. **Abstraction**: Hiding complex implementation details and exposing only necessary features.

## Constructor Functions

- Constructor function names should start with a capital letter (convention).
- In JavaScript, functions can act as constructors to create objects.
- Inside a constructor, **`this`** refers to the new object being created.
- Using the **`new`** keyword:
    - Creates a new empty object.
    - Calls the constructor function with `this` set to the new object.

### Example

```javascript
function User(id, userName) {
  this.i = id;
  this.u = userName;
}
```

## Classes in JavaScript

- JavaScript classes are syntactic sugar over constructor functions. Under the hood, a class is a function (`typeof` a class returns `"function"`).
- **instanceof**: Checks if an object is an instance of a specific class or constructor.
- Every object has a **`constructor`** property pointing to the function that created it.

### Example

```javascript
class User {
  constructor(id, userName) {
    this.i = id;
    this.u = userName;
  }
}

let user = new User(1, "Osama");
console.log(user instanceof User); // true
console.log(user.constructor === User); // true
```

### String vs String Constructor

- String literals (`let strOne = "elzero"`) have `typeof` `"string"`.
- Strings created with `new String("elzero")` have `typeof` `"object"`.

```javascript
let strOne = "elzero";
let strTwo = new String("elzero");

console.log(typeof strOne); // "string"
console.log(typeof strTwo); // "object"

console.log(strOne instanceof String); // false
console.log(strTwo instanceof String); // true

console.log(strOne.constructor === String); // true
console.log(strTwo.constructor === String); // true
```

## Default Values for Attributes

- Set default values either in the constructor parameter list (modern, readable) or inside the constructor body.

## Methods in Classes

- Methods declared directly in the class are shared across all instances via the prototype (memory efficient).
- Methods declared inside the constructor are created for each instance, consuming more memory.
- Calling a method without parentheses references the function object itself, showing its source code.

### Example

```javascript
class User {
  constructor(id, userName, salary) {
    this.i = id;
    this.u = userName;
    this.s = salary;
  }
  
  writeMsg() {
    return `Hello, ${this.u} Your Salary is ${this.s}`;
  }
}

let user = new User(1, "Osama", 5000);
console.log(user.writeMsg()); 
// "Hello, Osama Your Salary is 5000"

console.log(user.writeMsg); 
// Shows function source code
```

## Static Properties and Methods

- Declared with the **`static`** keyword, they belong to the class itself, not its instances.
- Accessible without creating an instance, unlike regular properties/methods which require instantiation.
- Use `ClassName.staticProperty` or `ClassName.staticMethod()`.

### Example

```javascript
class User {
  static count = 0;
  constructor(id, userName) {
    this.i = id;
    this.u = userName;
    User.count++;
  }
  static sayHello() {
    return "Hello from User class";
  }
}

console.log(User.count); // 0
let user = new User(1, "Osama");
console.log(User.count); // 1
console.log(User.sayHello()); // "Hello from User class"
```

## Inheritance

- Use the **`extends`** keyword to create a subclass that inherits from a parent class.
- **`super`**: Calls the parent class constructor or methods.
- Subclasses can override parent methods or extend functionality.

### Example

```javascript
class User {
  constructor(id, userName) {
    this.i = id;
    this.u = userName;
  }
  sayHello() {
    return `Hello, ${this.u}`;
  }
}

class Admin extends User {
  constructor(id, userName, permissions) {
    super(id, userName);
    this.p = permissions;
  }
  sayHello() {
    return `${super.sayHello()} from Admin`;
  }
}

let admin = new Admin(1, "Osama", "full");
console.log(admin.sayHello()); // "Hello, Osama from Admin"
```

## Encapsulation and Private Fields

- Private fields are denoted with a `#` prefix and are only accessible within the class where defined.
- Use methods (getters/setters) to access or manipulate private fields.
- Private fields are not inherited by subclasses but can be accessed via public methods.

### Example

```javascript
class User {
  [[e]];
  
  constructor(id, userName, eSalary) {
    this.i = id;
    this.u = userName;
    this.#e = eSalary;
  }
  
  getSalary() {
    return `Your salary is ${this.#e}`;
  }
}

class Admin extends User {
  constructor(id, userName, eSalary, permissions) {
    super(id, userName, eSalary);
    this.p = permissions;
  }
  getParentSalary() {
    return this.getSalary();
  }
}

let user = new User(1, "Osama", 5000);
console.log(user.getSalary()); // "Your salary is 5000"

// console.log(user.#e); 
// SyntaxError: Private field '#e' must be declared in an enclosing class
```

## Prototype

- A **prototype** is an object from which other objects inherit properties and methods.
- JavaScript uses a **prototype chain** to resolve properties/methods:
    - Checks the object itself first.
    - If not found, checks the object's prototype, then the prototype's prototype, until it reaches `null`.
- Access a class's prototype with `ClassName.prototype`.

### Example

```javascript
class User {
  constructor(id, userName) {
    this.i = id;
    this.u = userName;
  }
  sayHello() {
    return `Hello, ${this.u}`;
  }
}

console.log(User.prototype); // { constructor: f, sayHello: f }
console.log(String.prototype); // String prototype with built-in methods
```

### Adding to Prototype

- Add methods or properties to a prototype to make them available to all instances.
- Extend built-in constructors (e.g., `String`, `Object`) to add custom functionality.

```javascript
User.prototype.sayWelcome = function () {
  return `Welcome ${this.u}`;
};

Object.prototype.love = "We love JS"; // Adds to all objects
String.prototype.add_toTheEnd = function (val) {
  return `${val}_`;
};

let user = new User(1, "Osama");
console.log(user.sayWelcome()); // "Welcome Osama"
console.log({}.love); // "We love JS"
console.log("test".add_toTheEnd("test")); // "test_"
```

## Object Metadata and Descriptors


- Properties have three descriptor attributes (default: `false` when using `Object.defineProperty`):
    - **`writable`**: Whether the property value can be changed.
    - **`enumerable`**: Whether the property appears during enumeration (e.g., in `for...in` loops).
    - **`configurable`**: Whether the property descriptor can be modified or the property deleted.

- Properties added normally (e.g., `obj.prop = value`) have all descriptor attributes set to `true`.

### Example: `Object.defineProperty`

```javascript
let myObject = {};
Object.defineProperty(myObject, "c", {
  value: 3,
  writable: false,
  configurable: false,
  enumerable: false,
});

console.log(myObject.c); // 3
myObject.c = 5; // Ignored (writable: false)
console.log(delete myObject.c); // false (configurable: false)
```

### Example: `Object.defineProperties`

- Define multiple properties at once.

```javascript
let myObject = {};
Object.defineProperties(myObject, {
  c: {
    configurable: true,
    value: 3,
  },
  d: {
    configurable: false,
    value: 4,
  },
});

console.log(Object.getOwnPropertyDescriptor(myObject, "d"));
// { value: 4, writable: false, enumerable: false, configurable: false }
console.log(Object.getOwnPropertyDescriptors(myObject)); 
// { c: {...}, d: {...} }
```

## Getters

- **Getters** are methods defined with the `get` keyword that act like properties but compute values dynamically.
- Useful for creating virtual properties, data validation, or transformations.

### Example: Getter for Credit Card Formatting

```javascript
class User {
  [[c]];
  
  constructor(card) {
    this.#c = card;
  }
  
  get editCard() {
    return String(this.#c).replace(
      /(\d{4})(\d{4})(\d{4})(\d{4})/,
      "$1-$2-$3-$4"
    );
  }
}

let user = new User("1234567890123456");
console.log(user.editCard); // "1234-5678-9012-3456"
```

## Additional Notes

- **String.prototype Extension**:

```javascript
String.prototype.addLove = function () {
  return `I Love ${this} Web School`;
};
console.log("Elzero".addLove()); // "I Love Elzero Web School"
```

- **`this`**: Refers to the instance the method is called on.

- **Hiding Properties**:
    - Properties with `enumerable: false` are hidden from loops but still visible in `console.log`.
    - To completely hide a property, delete it with `delete myObj.country`.