
## Introduction to JSON

- **JSON** (JavaScript Object Notation) is a format for sharing data between server and client.
- Derived from JavaScript, its syntax is based on how objects and arrays are defined in JavaScript.
- Serves as an alternative to XML.
- File extension: `.json`.

## Why Use JSON?

- Easy to read and use.
- Supported by most programming languages and their frameworks.
- Allows conversion between JSON objects and JavaScript objects.

## JSON vs XML

|**JSON**|**XML**|
|---|---|
|Text-based format|Markup language|
|Lightweight|Heavier|
|Does not use tags|Uses tags|
|Shorter|Not short|
|Supports arrays|Does not support arrays|
|Does not support comments|Supports comments|

## JSON Syntax

- JSON objects differ from JavaScript objects in the following ways:
    - Keys must be strings and enclosed in double quotes.
    - No functions or methods are allowed.
    - No `Date` objects.
    - No `undefined` values.

### Example JSON Object

```json
{
  "string": "elzero",
  "number": 10,
  "boolean": true,
  "nul": null,
  "object": {
    "EG": "giza",
    "KSA": "Riadh"
  },
  "array": [1, 2, 3, 4]
}
```

***
## Application Programming Interface (API)

- An **API** (Application Programming Interface) provides a set of operations for developers to use, along with descriptions of what each operation does.

- Developers interact with APIs without needing to know the internal implementation, only the required input and expected output.

- Common use in frontend development: Retrieving or sending data to/from a server (e.g., fetching posts for a blog, creating/deleting posts).

- Example API endpoints for a blog:
    - `GET /posts`: Retrieve all posts.
    - `GET /posts/{id}`: Retrieve a specific post.
    - `POST /posts`: Create a new post.

- Data is typically sent to and received from the server as JSON objects.

## Working with JSON in JavaScript

- JSON data from a server is received as a **string**.
- Use **`JSON.parse`** to convert a JSON string to a JavaScript object.
- Use **`JSON.stringify`** to convert a JavaScript object to a JSON string for sending to the server.

### Example: Converting and Manipulating JSON

```javascript
// JSON string from server
const myJsonObjectFromServer = '{"UserName": "Osama", "Age": 30}';

// Convert JSON to JavaScript object
const myJSObject = JSON.parse(myJsonObjectFromServer);

// Update data
myJSObject["UserName"] = "Hamza";
myJSObject["Age"] = 22;

// Convert back to JSON string for sending to server
const myJsonObjectToTheServer = JSON.stringify(myJSObject);
console.log(typeof myJsonObjectToTheServer); // "string"
console.log(myJsonObjectToTheServer); // '{"UserName":"Hamza","Age":21}'
```

***
## Synchronous Programming

- Executes operations in sequence, where each operation waits for the previous one to complete before proceeding.

## Asynchronous Programming

- Operations run in parallel, allowing the program to continue executing other tasks without waiting for the completion of asynchronous operations.
- JavaScript is a **single-threaded** language, meaning it executes one operation at a time. However, it supports asynchronous behavior through mechanisms like **callbacks**, **promises**, and **async/await**.
- The **Web API** (provided by the browser) acts as a second thread to handle asynchronous tasks.

## Call Stack and Stack Trace

- The **call stack** manages execution contexts. When a function finishes executing, its context is popped off the stack.
- Code execution is synchronous by default.
- The call stack detects Web API methods (e.g., `setTimeout`) and delegates them to the browser for handling.

## Web API

- Provides browser-specific methods like `setTimeout`, `fetch`, and `XMLHttpRequest`.
- For example, `setTimeout` with a delay of 0ms does not execute immediately:
    - It starts a timer in the Web API environment.
    - When the timer expires, the callback is added to the **task queue**.
    - The JavaScript runtime continues executing other code and only processes the task queue when the call stack is empty.

```JS
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

console.log("3");

// 1 .. 3 .. 2
```

## Event Loop and Callback Queue

- The **event loop** manages the execution of tasks between the call stack and the task queue:
    1. The runtime pushes the main script or first function onto the call stack.
    2. The event loop checks if the call stack is empty. If not, it executes the stack's tasks.
    3. When the call stack is empty, the event loop moves tasks from the task queue to the call stack.
    4. The process repeats.

- **Callback queue**: Stores callbacks from asynchronous operations (e.g., `setTimeout`) after the Web API processes them.
- Asynchronous functions are sent to the Web API, processed, and their callbacks are added to the callback queue for execution.

## AJAX (Asynchronous JavaScript and XML)

- Combines technologies (HTML, CSS, JS, DOM) to interact with servers without refreshing the page.
- Uses the **`XMLHttpRequest`** object to make HTTP requests.
- **Status codes** indicate the response type (e.g., `200` for OK, `404` for Not Found, `403` for Forbidden).

### Example: XMLHttpRequest

```javascript
let req = new XMLHttpRequest();
req.open("GET", "https://api.github.com/users/elzerowebschool/repos", true);
req.send();

req.onreadystatechange = function () {
  if (this.readyState === 4 && this.status === 200) {
    console.log(this.responseText);
  }
};
```

### Ready States

- `0`: Request not initialized.
- `1`: Server connection established.
- `2`: Request received.
- `3`: Processing request.
- `4`: Request finished, and response is ready (does not guarantee success; check `status`).

### `XMLHttpRequest` Methods and Properties

- **`open(method, url, async, user, password)`**: Initializes a request (does not send it).
    - `method`: HTTP method (e.g., `GET`, `POST`, `PUT`, `DELETE`).
    - `async`: Boolean (default: `true` for asynchronous).
    - `user`, `password`: Optional for authentication.

- **`send()`**: Sends the request.
- **`onreadystatechange`**: Event triggered when the ready state changes.
- **`responseText`**: Holds the response data as a string.

### Looping Through Data

```javascript
let myReq = new XMLHttpRequest();
myReq.open("GET", "https://api.github.com/users/elzerowebschool/repos");
myReq.send();

myReq.onreadystatechange = function () {
  if (this.readyState === 4 && this.status === 200) {
    let myObj = JSON.parse(this.responseText);
    for (let i = 0; i < myObj.length; i++) {
      let myDiv = document.createElement("div");
      let text = document.createTextNode(myObj[i].full_name);
      myDiv.appendChild(text);
      document.body.appendChild(myDiv);
    }
  }
};
```

## Callback Hell (Pyramid of Doom)

- Occurs when callbacks are nested within callbacks, making code hard to read and maintain.
- **Callback**: A function passed as an argument to another function to be executed later.

### Example: Callback Hell

```javascript
getData(function (a) {
  getMoreData(a, function (b) {
    getMoreData(b, function (c) {
      getMoreData(c, function (d) {
        getMoreData(d, function (e) {
          // ...
        });
      });
    });
  });
});
```

***
## Promises

- A **Promise** represents the status of an asynchronous operation and its resulting value.
- **States**:
    - **Pending**: Outcome not yet determined.
    - **Fulfilled**: Operation completed, promise resolves to a value.
    - **Rejected**: Operation failed, promise rejects with an error.

- **Resolve**: Function that sets the promise state to fulfilled and assigns a value.
- **Reject**: Function that sets the promise state to rejected and assigns an error.

### Example: Promise

```javascript
let p = new Promise((resolve, reject) => {
  setTimeout(() => {
    let element = document.getElementById("h1");
    if (element) {
      element.style.display = "";
      resolve("Success: Element found and style updated");
    } else {
      reject(Error("Element Not Found"));
    }
  }, 2500);
})
  .then((message) => console.log(message))
  .catch((error) => console.log(error));
```

### Promise Methods

- **`then(resultCallback, errorCallback)`**:
    - First callback handles fulfilled state.
    - Second (optional) callback handles rejected state ... but only catches errors in the original promise, not errors in the `then` callback.

- **`catch(errorCallback)`**:
    - Catches errors from the promise or any preceding `then` in the chain.
    - Preferred for error handling.

- **`finally(callback)`**:
    - Executes regardless of whether the promise is fulfilled or rejected.

### Chaining `then`

- Use `return` in a `then` callback to pass data to the next `then`.

```javascript
p.then((response) => {
  let data = response.json();
  return data;
}).then((data) => console.log(data));
```

### Promises with XMLHttpRequest

```javascript
const getData = (apiLink) => {
  return new Promise((resolve, reject) => {
    let myReq = new XMLHttpRequest();
    myReq.onload = function () {
      if (this.readyState === 4 && this.status === 200) {
        resolve(JSON.parse(this.responseText));
      } else {
        reject(Error("No Data Found"));
      }
    };
    
    myReq.open("GET", apiLink);
    myReq.send();
  });
};

getData("https://api.github.com/users/elzerowebschool/repos")
  .then((result) => {
    result.length = 10;
    return result;
  })
  .then((result) => console.log(result[0].name))
  .catch((reject) => console.log(reject));
```

### `onload` vs `onreadystatechange`

- **`onload`**: Triggered once when the request completes successfully. Simpler to use.
- **`onreadystatechange`**: Triggered multiple times during the request lifecycle.

## Fetch API

- A modern alternative to `XMLHttpRequest` that returns a **Promise** resolving to a **Response** object.
- **`response.json()`**:
    - Reads and parses the response body into a JavaScript object/array.
    - Returns a Promise, as parsing is asynchronous.

### Example: Fetch

```javascript
fetch("https://api.github.com/users/elzerowebschool/repos")
  .then((response) => {
    let pro = response.json();
    return pro;
  })
  .then((data) => {
    data.length = 10;
    return data;
  })
  .then((ten) => {
    console.log(ten[0].name);
  });
```

## Promise Methods: `all`, `allSettled`, `race`

- **`Promise.all(iterable)`**:
    - Takes an array of promises and returns a single promise.
    - Resolves when all promises resolve, returning an array of their values.
    - Rejects if any promise rejects, returning the reason for rejection.

- **`Promise.allSettled(iterable)`**:
    - Resolves after all promises are either fulfilled or rejected, returning an array of objects with each promiseâ€™s status and value/reason.

- **`Promise.race(iterable)`**:
    - Resolves or rejects as soon as one promise in the iterable resolves or rejects, returning its value or reason.

### Example: `Promise.all`

```javascript
Promise.all([myFirstPromise, mySecondPromise, myThirdPromise])
  .then((result) => {
    console.log(result);
  })
  .catch((err) => console.log(err));
```

## Async/Await

- **`async`**: Declares a function as asynchronous, which always returns a **Promise**.
    - If the function returns a value, the promise resolves with that value.
    - If it throws an error, the promise rejects with that error.
    - If no value is returned, the promise resolves with `undefined`.

- **`await`**: Can only be used inside an `async` function. Pauses execution until the promise resolves, providing a cleaner syntax for handling asynchronous operations.

### Example: Async/Await

```javascript
async function getData() {
  let users = [];
  if (users.length > 0) {
    return "Users Found";
  } else {
    throw new Error("No users found");
  }
}

async function readData() {
  console.log("Before Promise");
  await myPromise; // Waits for the promise to resolve.
  console.log("After Promise");
}
```

### `Promise.resolve` and `Promise.reject`

- **`Promise.resolve(value)`**: Creates a promise that resolves with the given value.
- **`Promise.reject(reason)`**: Creates a promise that rejects with the given reason.

## Try, Catch, Finally

- Used for exception handling in asynchronous code:
    - **`try`**: Contains code that might throw an error.
    - **`catch`**: Handles errors thrown in the `try` block.
    - **`finally`**: Executes regardless of success or failure (optional, often used for cleanup).

### Example: Try/Catch with Fetch

```javascript
async function fetchData() {
  console.log("Before fetch");
  try {
    let myData = await fetch("https://api.github.com/users/elzerowebschool/repos");
    console.log(await myData.json());
  } catch (reason) {
    console.log(`Reason Is: ${reason}`);
  } finally {
    console.log("After fetch");
  }
}
```

### `fetch` vs `await fetch`

- `fetch(url)`: Returns a Promise, so `console.log(fetch(url))` logs the Promise object.
- `await fetch(url)`: Resolves the Promise and logs the Response object.

```javascript
let myData = fetch("https://api.github.com/users/elzerowebschool/repos");
console.log(myData); // Logs Promise object

let myData = await fetch("https://api.github.com/users/elzerowebschool/repos");
console.log(myData); // Logs Response object
```