## Generators

### Introduction

- A **generator function** runs its code on demand, pausing at each `yield` statement.
- Returns a **Generator Object**, which is iterable.
- Generators can be iterated using the `next()` method or a `for .. of` loop.
- A generator object can only be iterated once; subsequent iterations require creating a new generator object.
- The `yield` keyword can produce values from any iterable (e.g., strings, maps, sets, arrays).

### Example: Basic Generator

```javascript
function* generateNumber() {
  yield 1;
  yield 2; // Pauses here until next() is called again
  yield 3;
  yield 4;
}

let gen = generateNumber();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: 4, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

### Iterating with `for...of`

- The `for...of` loop automatically calls `next()` on the generator object, assigning the `value` property to the loop variable until `done` is `true`.

```javascript
for (let value of gen) {
  console.log(value); // 1, 2, 3, 4 (if gen is a new generator)
}
```

- **Note**: Using `for (let value of generateNumber())` creates a new generator object, ensuring iteration starts from the beginning, even if the generator was previously iterated.

- Using `for (let value of gen)` on an already-iterated generator will not yield values if `next()` was called prior to the loop.

### Delegate Generators

- Use `yield*` to delegate yielding to another generator, iterable, or iterator, yielding its values in sequence.
- `yield*` iterates over all values of the delegated iterable.

### Example: Delegating Generators

```javascript
function* generateNumbers() {
  yield 1;
  yield 2;
}

function* generateLetters() {
  yield "A";
  yield "B";
}

function* generateAll() {
  yield* generateNumbers(); // Yields 1, 2
  yield* generateLetters(); // Yields "A", "B"
  yield* [1, 2, 3]; // Yields 1, 2, 3 individually
}

let all = generateAll();

console.log(all.next()); // { value: 1, done: false }
console.log(all.next()); // { value: 2, done: false }
console.log(all.next()); // { value: "A", done: false }
console.log(all.next()); // { value: "B", done: false }
console.log(all.next()); // { value: 1, done: false }
console.log(all.next()); // { value: 2, done: false }
console.log(all.next()); // { value: 3, done: false }
console.log(all.next()); // { value: undefined, done: true }
```

- Without `yield*`, an iterable (e.g., `[1, 2, 3]`) would be yielded as a single value instead of individual elements.

### Using `return()` in Generators

- The `return(value)` method terminates the generator, setting `done` to `true` and returning the specified value.
- Any subsequent `next()` calls will not resume the generator.

```javascript
let iterator = generateNumber();

console.log(iterator.return("baz")); 
// { value: "baz", done: true }

console.log(iterator.next()); 
// { value: undefined, done: true }
```

### Generating Infinite Numbers

- Generators can produce infinite sequences by using a loop with `yield`.

```javascript
function* generateNums() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

let infinite = generateNums();
console.log(infinite.next().value); // 0
console.log(infinite.next().value); // 1
console.log(infinite.next().value); // 2
```

### Using `return` Inside Generators

- A `return` statement inside a generator stops execution and sets `done` to `true` .. **Code after `return` is unreachable**.

```javascript
function* generateNums() {
  yield 1;
  yield 2;
  return "3"; 
  // Stops generator, returns { value: "3", done: true }
  
  yield 4; // Unreachable
}

let gen = generateNums();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: "3", done: true }
console.log(gen.next()); // { value: undefined, done: true }
```

## Modules (Import and Export)

### Introduction

- JavaScript modules allow code to be split into reusable files.
- To use modules, set the HTML script tag to `type="module"`:

```html
<script type="module" src="main.js"></script>
```

### Named Exports

- Export variables, functions, or objects using their names in curly braces.
- Can export multiple items from a module.
- Syntax: `export { variable, function, object }` or `export` before each declaration.

```javascript
// main.js
export let a = 10;
export let myArr = [1, 2, 3];

export let myObj = { name: "Osama" };

export function something() {
  return "Something";
}
```

### Importing Named Exports

- Import specific items using their names in curly braces.
- Use `as` for aliases to rename imports.

```javascript
// app.js
import { a, myArr, something as s, myObj } from "./main.js";

console.log(s()); // "Something"
```

### Default Exports

- A module can have only one default export.
- Declared with `export default`.
- Imported without curly braces, and any name can be used for the import.

```javascript
// main.js
export default function saySomething() {
  return "Default export";
}

// app.js
import anyName from "./main.js";
console.log(anyName()); // "Default export"
```

- Default exports can be anonymous and still imported with any name.
- Combine default and named imports:

```javascript
import defaultExport, { a, myArr, something } from "./main.js";
```

### Exporting with Aliases

- Use `as` to rename exports in the module.

```javascript
// main.js
export { a, myArr, something as fun };

// app.js
import { fun } from "./main.js";
console.log(fun()); // "Something"
```