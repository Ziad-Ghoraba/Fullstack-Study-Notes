### Selectors

- `getElementById`, `getElementsByTagName`, `getElementsByClassName`
- `querySelector`, `querySelectorAll`

```js
let userAge = document.querySelector("[name='age']");
```

- Note that `getElementsByClassName` and `getElementsByTagName` returns a live HTML collection .. this means that the collection is updated automatically .. Unlike the `querySelectorAll` that returns a static Node List that doesn't update automatically when the content changes.
### Content

- `innerHTML`.
- `textContent` ... returns all text regardless of visibility .. but **consider the nested tags**.
- `innerText` ... **Only the visible text and doesn't consider the nested tags**.
- `getAttribute()`, `setAttribute()`.

```js
myEvent.innerHTML = "<p>Hello</p>";
myEvent.setAttribute("class", "My-Span");
```

 **Some Advanced Notes ...**

- Performance: `textContent` and `innerText` are generally faster that `innerHtml` when setting the content of an element.
-  Security: `innerHtml` can potentially open up your site to cross-site scripting (XSS) attacks.

### Create Elements

- `createElement()`, `createTextNode()`, `createComment()`, `appendChild()`, `append()` ... append more than one element.

```js
let div = document.createElement("div");
let p = document.createElement("p");

p.textContent = "Hello";
div.appendChild(p);

document.body.appendChild(div);
```

### Check Attributes

- `Element.attributes()`.
- `Element.hasAttribute("attributeName")`.
- `Element.hasAttributes()`.
- `Element.removeAttribute("attributeName")`.

### Deal With Children

- `element.children()` ... returns all the **element children** and it's not returning the nested children neither the comments.
- `element.childNodes()` ... returns everything.

- `element.firstChild(), element.lastChild(), firstElementChild(), lastElementChild()`.
### Events

- `onclick`, `oncontextmenu`, `onmouseenter`, `onmouseleave`.
- `oninput` ... whenever the input value changes whatever it's by pasting or entering a value.
- `onload`, `onscroll`, `onresize`, `onfocus`, `onblur`, `onsubmit`

```JS
  document.getElementById("myBtn").onclick = function () {
    alert("Button clicked!");
  };
```

***
- `addEventListener(event, func)`
- When there's two events attached to the element .. like `onclick` event you use it twice to add to events .. the second one will override the first one.

- `addEventListener` .. one of it's biggest benefits is adding an event to an element that's not in the page yet

- attach multiple lines .. you can add multiple events listeners to the same element for the same event type and they all will be called .. and this is the key advantage for the `addEventListener`.

```js
button.addEventListener("click", () => {
  fun1();
  fun2();
});
```

***
- `preventDefault()` ... is to prevent the default behavior.. what ever it was.
- We can simulate some events like selecting some button then `.click()`.

### Class List

- `length`, `contains("class")`, `item(index)`, `add()`, `remove()`, `toggle()`.
- Note that **add, remove and toggle** can take more than one token.

###  Dealing with elements

- `before()` .. used to add element or string before the selected element ... `element.before("This is comment")` or `element.before(createdP)`.
- `after`.
- `append(element or string)`.
- `prepend ()` .. the same but add them in the beginning of the element.
- `remove()` .. to remove the element ... `element.remove()`

### Styling

- `style` .. `element.style` and after that you can access any CSS property using the camelCase typing method.
- `cssText`, `setProperty()`, `removeProperty()`.

```js
element.style.cssText = "color: red; font-size: 20px";
element.style.setProperty("color", "#234", "important");
element.style.removeProperty("color");
```

### Traversing

- `nextSibling` ... returns the next sibling whatever it's kind .. note that the space is considered a node.
- `previousSibling`.
- `nextElementSibling`.
- `previousElementSibling`.
- `parentElement`.

### Cloning

- `cloneNode(deep)`: it's used to make a duplicate of the item without effecting the original one .. and the deep attribute is Boolean if it's true then the `cloneNode` will go deep and clone also the inside elements .. if false just will clone the father element .. the default is false.

- Note It won't clone the events.
- Note that when duplicating item it's id is duplicated so and not changed so that may cause a problems.

```js
let myDub = element.cloneNode(true);
myDub.id = `${myDub.id}-1`; // Avoid ID conflicts
```
